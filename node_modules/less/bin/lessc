#!/usr/bin/env node

var path = require('path'),
    fs = require('fs'),
    sys = require('util'),
<<<<<<< HEAD
    os = require('os');
=======
    os = require('os'),
    mkdirp;
>>>>>>> af11bda... add node_modules

var less = require('../lib/less');
var args = process.argv.slice(1);
var options = {
<<<<<<< HEAD
    compress: false,
    yuicompress: false,
    optimization: 1,
    silent: false,
=======
    depends: false,
    compress: false,
    yuicompress: false,
    max_line_len: -1,
    optimization: 1,
    silent: false,
    verbose: false,
    lint: false,
>>>>>>> af11bda... add node_modules
    paths: [],
    color: true,
    strictImports: false,
    rootpath: '',
<<<<<<< HEAD
    relativeUrls: false
=======
    relativeUrls: false,
    ieCompat: true,
    strictMath: false,
    strictUnits: false
>>>>>>> af11bda... add node_modules
};
var continueProcessing = true,
    currentErrorcode;

// calling process.exit does not flush stdout always
// so use this to set the exit code
process.on('exit', function() { process.reallyExit(currentErrorcode) });

<<<<<<< HEAD
=======
var checkArgFunc = function(arg, option) {
    if (!option) {
        sys.puts(arg + " option requires a parameter");
        continueProcessing = false;
        return false;
    }
    return true;
};

var checkBooleanArg = function(arg) {
    var onOff = /^((on|t|true|y|yes)|(off|f|false|n|no))$/i.exec(arg);
    if (!onOff) {
        sys.puts(" unable to parse "+arg+" as a boolean. use one of on/t/true/y/yes/off/f/false/n/no");
        continueProcessing = false;
        return false;
    }
    return Boolean(onOff[2]);
};

>>>>>>> af11bda... add node_modules
args = args.filter(function (arg) {
    var match;

    if (match = arg.match(/^-I(.+)$/)) {
        options.paths.push(match[1]);
        return false;
    }

<<<<<<< HEAD
    if (match = arg.match(/^--?([a-z][0-9a-z-]*)(?:=([^\s]+))?$/i)) { arg = match[1] }
=======
    if (match = arg.match(/^--?([a-z][0-9a-z-]*)(?:=([^\s]*))?$/i)) { arg = match[1] }
>>>>>>> af11bda... add node_modules
    else { return arg }

    switch (arg) {
        case 'v':
        case 'version':
            sys.puts("lessc " + less.version.join('.') + " (LESS Compiler) [JavaScript]");
            continueProcessing = false;
        case 'verbose':
            options.verbose = true;
            break;
        case 's':
        case 'silent':
            options.silent = true;
            break;
<<<<<<< HEAD
=======
        case 'l':
        case 'lint':
            options.lint = true;
            break;
>>>>>>> af11bda... add node_modules
        case 'strict-imports':
            options.strictImports = true;
            break;
        case 'h':
        case 'help':
            require('../lib/less/lessc_helper').printUsage();
            continueProcessing = false;
        case 'x':
        case 'compress':
            options.compress = true;
            break;
<<<<<<< HEAD
        case 'yui-compress':
            options.yuicompress = true;
            break;
        case 'no-color':
            options.color = false;
            break;
        case 'include-path':
            if (!match[2]) {
                sys.puts("include-path option requires a parameter");
                continueProcessing = false;
            } else {
=======
        case 'M':
        case 'depends':
            options.depends = true;
            break;
        case 'yui-compress':
            options.yuicompress = true;
            break;
        case 'max-line-len':
            if (checkArgFunc(arg, match[2])) {
                options.maxLineLen = parseInt(match[2], 10);
                if (options.maxLineLen <= 0) {
                  options.maxLineLen = -1;
                }
            }
            break;
        case 'no-color':
            options.color = false;
            break;
        case 'no-ie-compat':
            options.ieCompat = false;
            break;
        case 'include-path':
            if (checkArgFunc(arg, match[2])) {
>>>>>>> af11bda... add node_modules
                options.paths = match[2].split(os.type().match(/Windows/) ? ';' : ':')
                    .map(function(p) {
                        if (p) {
                            return path.resolve(process.cwd(), p);
                        }
                    });
            }
            break;
        case 'O0': options.optimization = 0; break;
        case 'O1': options.optimization = 1; break;
        case 'O2': options.optimization = 2; break;
        case 'line-numbers':
<<<<<<< HEAD
            options.dumpLineNumbers = match[2];
            break;
        case 'rp':
        case 'rootpath':
            if (!match[2]) {
                sys.puts("rootpath option requires a parameter");
                continueProcessing = false;
            } else {
                options.rootpath = path.normalize(match[2] + '/').replace('\\', '/');
=======
            if (checkArgFunc(arg, match[2])) {
                options.dumpLineNumbers = match[2];
            }
            break;
        case 'rp':
        case 'rootpath':
            if (checkArgFunc(arg, match[2])) {
                options.rootpath = match[2].replace(/\\/g, '/');
>>>>>>> af11bda... add node_modules
            }
            break;
        case "ru":
        case "relative-urls":
            options.relativeUrls = true;
            break;
<<<<<<< HEAD
=======
        case "sm":
        case "strict-math":
            if (checkArgFunc(arg, match[2])) {
                options.strictMath = checkBooleanArg(match[2]);
            }
            break;
        case "su":
        case "strict-units":
            if (checkArgFunc(arg, match[2])) {
                options.strictUnits = checkBooleanArg(match[2]);
            }
            break;
>>>>>>> af11bda... add node_modules
    }
});

if (!continueProcessing) {
    return;
}

var input = args[1];
<<<<<<< HEAD
=======
var inputbase = args[1];
>>>>>>> af11bda... add node_modules
if (input && input != '-') {
    input = path.resolve(process.cwd(), input);
}
var output = args[2];
<<<<<<< HEAD
=======
var outputbase = args[2];
>>>>>>> af11bda... add node_modules
if (output) {
    output = path.resolve(process.cwd(), output);
}

if (! input) {
    sys.puts("lessc: no input files");
    sys.puts("");
    require('../lib/less/lessc_helper').printUsage();
    currentErrorcode = 1;
    return;
}

var ensureDirectory = function (filepath) {
    var dir = path.dirname(filepath),
<<<<<<< HEAD
        existsSync = fs.existsSync || path.existsSync;
    if (!existsSync(dir)) {
        fs.mkdirSync(dir);
    }
};

=======
        cmd,
        existsSync = fs.existsSync || path.existsSync;
    if (!existsSync(dir)) {
        if (mkdirp === undefined) {
            try {mkdirp = require('mkdirp');}
            catch(e) { mkdirp = null; }
        }
        cmd = mkdirp && mkdirp.sync || fs.mkdirSync;
        cmd(dir);
    }
};

if (options.depends) {
    if (!outputbase) {
        sys.print("option --depends requires an output path to be specified");
        return;
    }
    sys.print(outputbase + ": ");
}

>>>>>>> af11bda... add node_modules
var parseLessFile = function (e, data) {
    if (e) {
        sys.puts("lessc: " + e.message);
        currentErrorcode = 1;
        return;
    }

<<<<<<< HEAD
    new(less.Parser)({
        paths: [path.dirname(input)].concat(options.paths),
        optimization: options.optimization,
        filename: input,
        rootpath: options.rootpath,
        relativeUrls: options.relativeUrls,
        strictImports: options.strictImports,
        dumpLineNumbers: options.dumpLineNumbers
    }).parse(data, function (err, tree) {
=======
    options.paths = [path.dirname(input)].concat(options.paths);
    options.filename = input;

    var parser = new(less.Parser)(options);
    parser.parse(data, function (err, tree) {
>>>>>>> af11bda... add node_modules
        if (err) {
            less.writeError(err, options);
            currentErrorcode = 1;
            return;
<<<<<<< HEAD
        } else {
            try {
                var css = tree.toCSS({
                    compress: options.compress,
                    yuicompress: options.yuicompress
=======
        } else if (options.depends) {
            for(var file in parser.imports.files) {
                sys.print(file + " ")
            }
            sys.print("\n");
        } else if(!options.lint) {
            try {
                var css = tree.toCSS({
                    silent: options.silent,
                    verbose: options.verbose,
                    ieCompat: options.ieCompat,
                    compress: options.compress,
                    yuicompress: options.yuicompress,
                    maxLineLen: options.maxLineLen,
                    strictMath: options.strictMath,
                    strictUnits: options.strictUnits
>>>>>>> af11bda... add node_modules
                });
                if (output) {
                    ensureDirectory(output);
                    fs.writeFileSync(output, css, 'utf8');
                    if (options.verbose) {
                        console.log('lessc: wrote ' + output);
                    }
                } else {
                    sys.print(css);
                }
            } catch (e) {
                less.writeError(e, options);
                currentErrorcode = 2;
                return;
            }
        }
    });
};

if (input != '-') {
    fs.readFile(input, 'utf8', parseLessFile);
} else {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    var buffer = '';
    process.stdin.on('data', function(data) {
        buffer += data;
    });

    process.stdin.on('end', function() {
        parseLessFile(false, buffer);
    });
}
